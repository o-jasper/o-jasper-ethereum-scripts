// Special positions
data changer
data implementer
data boardadd

data member_cnt
data member_i
data member_max_i
data members[]

data proposal_cnt
data proposal[](info, body[], votes[])

HALFWAY = 
ADDR_PART = 1461501637330902918203684832716283019655932542976

def init():
     self.changer = msg.sender
     self.boardadd = msg.sender

def changer_changer(data:arr):
     if msg.sender == self.changer:
         self.changer = data[0]
         self.implementer = data[1]
         self.boardadd = data[2]
         // TODO rest of changing data to implementer.

// Fuss is about adding people 'efficiently'..
// It might limit their voting on older cases?!
// Can "neutralize" the votes there, however.
def boardadd_add_member(addr):
    if msg.sender == self.boardadd:
        i = self.member_i
        while self.member[i] != 0:
            i += 1
        self.member[i] = addr
        self.member_i = i + 1
        if i > self.member_max_i:
            self.member_max_i = i
        self.member_cnt += 1

def boardadd_remove_member(addr):
    if msg.sender == self.boardadd:  // Just nukes it.
        i = 0
        while i < member_i:
            if self.member[i] % ADDR_PART == addr:
                if i < self.member_i:
                    self.member_i = i
                self.member[i] = 0
                self.member_removed_cnt += 1
                return
            i += 1

// Zero out a proposal we're done with to save space.
def implementer_remove_proposal(i, l):
    if msg.sender == self.implementer:
        self.proposal[i].info = 0
        if l < 256:
            j = 0  // Zero out the body.
            while j < l:
                self.proposal[i].body[j] = 0
                j += 1
        j = 0  // Zero out the votes.
        while j < member_i/128 + 1:
            self.proposal[i].votes[j] = 0
            j += 1

// Tell implementer about result. Implementer decides if enough votes or not.
def poke_proposal(proposal_i):
    if proposal_i < self.proposal_cnt:
        0 //TODO send info and body. Implementer figures if that is enough votes for that.

def add_proposal(body:arr):
    i = 0
    while i < len(body):
        self.proposal[self.proposal_cnt].body[i] = body[i]
        i += 1
    self.proposal_cnt += 1

def vote_for_i(member_i, proposal_2i):
    if proposal_2i/2 < self.proposal_cnt:
        // Vote if not already voted.
        if msg.sender == self.members[member_i]%ADDR_PART | msg.sender == self:
            got = self.proposal[proposal_2i/2].votes[member_i/128]
            k   = proposal_2i%2 + 2*(member_i%128)
            if (got & 2^k) == 0:
                self.proposal[proposal_2i/2].votes[member_i/128] = got | 2^k
                self.proposal[proposal_2i/2].info += !(proposal_2i%2) + (proposal_2i%2)*HALFWAY

def vote_for(proposal_2i):
    member_i = 0
    while member_i < self.member_max_i:
        if msg.sender == self.members[member_i]%ADDR_PART:
            self.vote_for(member_i, proposal_2i)
        member_i += 1

// Get information out.
def changer():
    return self.changer

def implementer():
    return self.implementer

def boardadd():
    return self.boardadd


def member_i():
    return self.member_i

def member_cnt():
    return self.member_cnt

def member(i):
    return self.members[i]

def member_addr(i):
    return self.members[i]%ADDR_PART

def proposal_cnt():
    return self.proposal_cnt

def proposal_info(i):
    return self.proposal[i].info

//def proposal_body(i)
// TODO
//dewf proposal_votes(i,j)
